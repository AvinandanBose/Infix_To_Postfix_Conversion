<h1 align="Center">𝑰𝒏𝒇𝒊𝒙 𝒕𝒐 𝑷𝒐𝒔𝒕𝒇𝒊𝒙 𝑪𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏<h1>

<h3 align="Center"><ins>𝑻𝒐 𝒔𝒕𝒂𝒓𝒕 𝒘𝒊𝒕𝒉 𝒘𝒆 𝒂𝒍𝒍 𝒉𝒂𝒗𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏𝒂𝒓𝒊𝒆𝒔:</ins></h3>
  
 <ul>
   
 ![Screenshot (539)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/e7fa846d-3ea8-4b4c-8bc9-39ffe28e5cd6)
 
 </ul>
  
  <h3 align="Center"><ins>𝑪𝒓𝒆𝒂𝒕𝒊𝒐𝒏 𝒐𝒇 𝑺𝒕𝒂𝒄𝒌:</ins></h3>
  
 <ul>
   
![Screenshot (540)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/0ea03bd0-a602-4837-b653-286113f915a8)

 
 </ul>
  
  <h3 align="Center"><ins>𝑪𝒉𝒆𝒄𝒌 𝑰𝒔𝑬𝒎𝒑𝒕𝒚 𝒐𝒇 𝑺𝒕𝒂𝒄𝒌:</ins></h3>
  
<ul>

![Screenshot (541)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/12071975-33ea-40fe-bd76-c42e2bb0a07f)


 
 </ul>
  
<h3 align="Center"><ins>𝑪𝒉𝒆𝒄𝒌𝒊𝒏𝒈 𝑺𝒕𝒂𝒄𝒌 𝒊𝒔 𝒇𝒖𝒍𝒍:</ins></h3>
  
<ul>
    
![Screenshot (542)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/7211d2ff-db21-4073-a90e-5f04acc41d02)
    
    
</ul>
  
  
<h3 align="Center"><ins>𝑷𝒖𝒔𝒉𝒊𝒏𝒈 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌</ins></h3>
  
<ul>

![Screenshot (544)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/9cfac5ca-d273-4389-883e-8cd33568c40d)

  
</ul>
  
  
<h3 align="Center"><ins>𝑷𝒐𝒑𝒊𝒏𝒈 𝑬𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌</ins></h3>
  
<ul>

![Screenshot (545)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/1511eb7e-e173-4c9f-a6f3-5799b2c9ca5a)
 
<h3> 𝑨𝒔 𝒘𝒆 𝒂𝒓𝒆 𝒅𝒆𝒂𝒍𝒊𝒏𝒈 𝒘𝒊𝒕𝒉 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓𝒔 , 𝒉𝒆𝒏𝒄𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝒕𝒚𝒑𝒆 𝒘𝒊𝒍𝒍 𝒃𝒆
𝒂 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓.</h3>
  
</ul>
  
<h3 align="Center"><ins>𝑺𝒖𝒑𝒑𝒐𝒔𝒆 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒓𝒊𝒕𝒉𝒎𝒆𝒕𝒊𝒄 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏:</ins></h3>

  
<h3 align="Center">  (𝒂 + 𝒃) ∗ (𝒄^𝒅)/𝒆</h3>
  
  <h2></h2> 
 <h2><ins> 𝟏) 𝑨𝒕 𝒇𝒊𝒓𝒔𝒕 𝒊𝒕 𝒄𝒓𝒆𝒂𝒕𝒆𝒔 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌. </ins></h2>
  
  ![Screenshot (546)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/30e109f8-bfaa-46cf-88e9-27139bab42ae)


 <h2></h2>
 <h2><ins>𝟐) 𝑵𝒐𝒘 𝒇𝒓𝒐𝒎 𝒑𝒓𝒊𝒐𝒓𝒊𝒕𝒚 𝒄𝒉𝒆𝒄𝒌𝒆𝒓 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝟎 𝒇𝒐𝒓 (.</ins></h2>
  
  ![Screenshot (547)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/1ff4a30f-5eb1-4c4d-bbbf-2ea1efe361d0)
 
  <h2></h2>
 <h2><ins>𝟑) 𝑵𝒐𝒘 𝒊𝒇 𝒊𝒕𝒔 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒂𝒏𝒅 𝒊𝒕 𝒎𝒖𝒔𝒕 𝒏𝒐𝒕 𝒄𝒐𝒎𝒆
𝒂𝒕 𝒇𝒊𝒓𝒔𝒕 𝒂𝒔 𝒘𝒆 𝒅𝒐𝒊𝒏𝒈 𝒊𝒏𝒇𝒊𝒙 𝒕𝒐 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒄𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏. </ins></h2>
 
  <ul>
  
<h3>𝑻𝒉𝒂𝒕 𝒊𝒔 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒊𝒔: </h3>
    
<h3>
 
```Syntax
  
(𝒂 + 𝒃) ∗ (𝒄^𝒅)/𝒆 
  
```
  
  
</h3>

<h3>𝑨𝒏𝒅 𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅() 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒕𝒂𝒌𝒆𝒔 𝒂 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒏 𝒊𝒕𝒔 𝒑𝒂𝒓𝒂𝒎𝒆𝒕𝒆𝒓: </h3>
    
![Screenshot (548)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/5ec10fdd-4c11-410f-b9a8-9551cdedfbbd)

<h3>   𝒊𝒇 𝒏𝒐𝒕 𝒂 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒃𝒖𝒕 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒕𝒉𝒆𝒏 𝒓𝒆𝒕𝒖𝒓𝒏 𝟎 𝒐𝒓 𝒇𝒂𝒍𝒔𝒆, 
𝒐𝒕𝒉𝒆𝒓𝒘𝒊𝒔𝒆 𝟏 𝒐𝒓 𝒕𝒓𝒖𝒆. </h3>
    
    
 ![Screenshot (549)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/3fb6c1bf-2a11-490a-ba55-d3a7e2d0d0a7)
    
<h3>  𝑨𝒏𝒅 𝒂𝒔 𝒊𝒕 𝒓𝒆𝒕𝒖𝒓𝒏𝒔 𝟎 ,𝒊𝒕 𝒘𝒊𝒍𝒍 𝒔𝒌𝒊𝒑 𝒕𝒉𝒆 𝒊𝒇 𝒑𝒂𝒓𝒕 . 𝑰𝒇 𝒘𝒊𝒍𝒍 𝒓𝒖𝒏
𝒘𝒉𝒆𝒏 𝒕𝒉𝒆 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒓𝒆𝒕𝒖𝒓𝒏𝒔 𝟏 (𝒕𝒓𝒖𝒆).</h3>
    
<h3> 𝑯𝒆𝒏𝒄𝒆 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒏𝒐𝒘 𝒆𝒏𝒕𝒆𝒓 𝒕𝒉𝒆 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕:</h3>
    
![Screenshot (550)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/ede3490d-aa9c-48a2-8128-939716ebd1b2)
    
    
<h3>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊𝒏𝒇𝒊𝒙[𝟎]]) = 𝒑𝒓𝒆( `(` ) = 𝟎 > 𝒑𝒓𝒆(𝒔𝒕. 𝒔[𝒔𝒕. 𝒕𝒐𝒑])
= −𝟏 𝒊𝒔 𝒕𝒓𝒖𝒆 𝒐𝒓 𝒊𝒔𝑬𝒎𝒑𝒕𝒚(𝒔𝒕) = 𝒕𝒓𝒖𝒆 𝒂𝒍𝒔𝒐 𝒊𝒏𝒇𝒊𝒙[𝟎] = `(` 𝒊𝒔
𝒕𝒓𝒖𝒆.</h3>
<h3> 𝒑𝒖𝒔𝒉 → `(` . 𝑨𝒏𝒅 𝒊 + += 𝒊 + 𝟏 = 𝟎 + 𝟏 = 𝟏.</h3>
<h3> 𝑨𝒏𝒅 𝒂𝒍𝒔𝒐 𝒏𝒐𝒘 𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = −𝟏 + 𝟏 = 𝟎.</h3>
    
![Screenshot (552)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/1aa22fb2-8097-4da6-9c3b-0d3eea374142)


    

    
 </ul>

  <h2></h2>
 <h2><ins>𝟒) 𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 `𝒂`.  </ins></h2>


<ul>
  
<h3>𝒊 = 𝟏 𝒂𝒏𝒅 𝒋 = 𝟎. </h3>
  
  ![Screenshot (553)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/db8857d0-16b0-47f3-8c64-ad3a9622eed5)

 <h3> 𝑵𝒐𝒘 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 `𝒂` 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝟏 (𝒕𝒓𝒖𝒆)𝒊. 𝒆. 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅
𝒂𝒏𝒅 𝒊𝒕𝒔 𝒕𝒚𝒑𝒆 𝒊𝒔 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓:</h3>
  
  ![Screenshot (555)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/d994f49b-6e8b-4989-a95c-5f1250ac50d6)

  <h3> 𝑨𝒔 𝒘𝒆 𝒓𝒆𝒕𝒖𝒓𝒏 𝟏 𝒊𝒇 𝒔𝒕𝒂𝒕𝒆𝒎𝒆𝒏𝒕𝒔 𝒓𝒖𝒏𝒔:</h3>
  
  ![Screenshot (556)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/90a1c9f9-d812-44cf-b9d9-a3f0b0f9d824)
  
 <h3>𝒑𝒐𝒔𝒕𝒇𝒊𝒙 [𝟎] = 𝒊𝒏𝒇𝒊𝒙[𝟏] = 𝒂 </h3>
 <h3>𝒋 + + = 𝒋 + 𝟏 = 𝟎 + 𝟏 = 𝟏 </h3>
 <h3>𝒊 = 𝒊 + 𝟏 = 𝟏 + 𝟏 = 𝟐 </h3>
 
 
 <h3>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂</h3>
 
 <h2></h2>
 <h2><ins>  𝟓) 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 ` + ` </ins></h2>
  
<ul>
  
 <h3>𝑯𝒆𝒏𝒄𝒆 𝒏𝒐𝒘 𝒂𝒈𝒂𝒊𝒏 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝟎.</h3>
  
  ![Screenshot (557)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/a0a5dc18-a081-4763-952d-ff5e52395997)
  
 <h3> 𝑨𝒏𝒅 𝒕𝒉𝒆𝒏 𝒊𝒕 𝒓𝒖𝒏𝒔 𝒕𝒉𝒆 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕:</h3>
  
  ![Screenshot (558)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/17b94914-7bef-4c77-bfea-a96fd48d5260)
  
  
<h3>  𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊𝒏𝒇𝒊𝒙[𝟐]]) = 𝒑𝒓𝒆( ` + `) = 𝟏 > 𝒑𝒓𝒆(𝒔𝒕. 𝒔[𝒔𝒕. 𝒕𝒐𝒑])
= 𝒑𝒓𝒆(𝒔𝒕. 𝒔[𝟎]) = 𝒑𝒓𝒆(`(`) = 𝟎 𝒊𝒔 𝒕𝒓𝒖𝒆 .</h3>
<h3>𝒑𝒖𝒔𝒉 → ` + ` 𝒊𝒔 𝒕𝒓𝒖𝒆. 𝑨𝒏𝒅 𝒊 + += 𝒊 + 𝟏 = 𝟐 + 𝟏 = 𝟑.</h3>
<h3>𝑨𝒏𝒅 𝒂𝒍𝒔𝒐 𝒏𝒐𝒘 𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = 𝟎 + 𝟏 = 𝟏.</h3>
  
  
![Screenshot (559)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/a1998581-4bd6-4f04-9b06-e112a461ffe6)



 </ul>
  
 <h2></h2>  
<h2><ins>  𝟔) 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 `𝒃` </ins></h2>
  
<ul>
  
𝒊 = 𝟑,𝒋 = 𝟏.
  
![Screenshot (560)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/814ebae9-6c75-41fb-a9b4-6e6c03aea437)

<h3> 𝑵𝒐𝒘 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 `𝒃` 𝒘𝒊𝒍𝒍 𝒓𝒆𝒕𝒖𝒓𝒏 𝟏 (𝒕𝒓𝒖𝒆)𝒊. 𝒆. 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 𝒂𝒏𝒅 𝒊𝒕𝒔 𝒕𝒚𝒑𝒆 𝒊𝒔 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓:</h3>
  
  ![Screenshot (561)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/4d9e67cb-975a-42b5-a1bf-9988eaa203aa)

<h3>𝒑𝒐𝒔𝒕𝒇𝒊𝒙 [𝟏] = 𝒊𝒏𝒇𝒊𝒙[𝟑] = 𝒃 .</h3>
<h3>𝒋 + + = 𝒋 + 𝟏 = 𝟏 + 𝟏 = 𝟐 .</h3>
<h3>𝒊 = 𝒊 + 𝟏 = 𝟑 + 𝟏 = 𝟒 .</h3>
 
<h3>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃</h3>
  
</ul>

<h2></h2>  
<h2><ins>  𝟕) 𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊. 𝒆. `)` </ins></h2>

<ul>
  
 <h3>𝑵𝒐𝒘 𝒍𝒐𝒈𝒊𝒄 𝒊𝒔 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒏𝒐𝒕 𝒑𝒖𝒔𝒉 ) 𝒓𝒂𝒕𝒉𝒆𝒓 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒑𝒐𝒑 𝒐𝒖𝒕 𝒕𝒉𝒆 
𝒆𝒍𝒆𝒎𝒆𝒏𝒕 ` + ` 𝒊𝒏 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒈𝒂𝒊𝒏 𝒑𝒐𝒑 𝒐𝒖𝒕 𝒕𝒉𝒆 
𝒐𝒑𝒆𝒏𝒊𝒏𝒈 𝒃𝒓𝒂𝒄𝒆 `)` .</h3>
  
<h3>𝑵𝒐𝒘 𝟏𝒔𝒕 𝒑𝒐𝒑 𝒘𝒊𝒍𝒍 𝒄𝒐𝒏𝒕𝒊𝒏𝒖𝒆 𝒍𝒆𝒔𝒔 𝒕𝒉𝒂𝒏 `(` 𝒐𝒑𝒆𝒏𝒊𝒏𝒈 𝒃𝒓𝒂𝒄𝒆. </h3>
  
 ![Screenshot (562)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/c8f28d1f-c9f1-4de9-ad9d-70674014f84f)
  
<h3>𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅(𝒊𝒏𝒇𝒊𝒙[𝟒] = `)`) = 𝟎[𝑭𝒂𝒍𝒔𝒆], 𝒉𝒆𝒏𝒄𝒆 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕 𝒓𝒖𝒏𝒔. 
  
<h3>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝟒] = `)` ) = 𝟎 ≤ 𝒑𝒓𝒆(𝒔[𝒕𝒐𝒑] = 𝒔[𝟏] = ` + `)
= 𝟏 𝒊𝒔 𝒕𝒓𝒖𝒆 𝒂𝒏𝒅 𝒊𝒏𝒇𝒊𝒙[𝟒] = `)` 
𝒊𝒔 𝒕𝒓𝒖𝒆. </h3>
  
<h3>𝑻𝒉𝒆𝒏: </h3>
  
<h3>
  
```Syntax
  
𝑾𝒉𝒊𝒍𝒆(𝒕𝒐𝒑 ! = [𝒏𝒐𝒕 𝒆𝒒𝒖𝒂𝒍 𝒕𝒐] ’(‘){ 
𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝟐] = 𝒑𝒐𝒑() = ` + ` ; 
 𝒋 + +; 
} 
  
``` 
</h3>  
  
<h3>𝒋 = 𝒋 + 𝟏 = 𝟐 + 𝟏 = 𝟑 𝒂𝒏𝒅 𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟏 − 𝟏 = 𝟎 .</h3>
 
<h3>𝑻𝒉𝒆𝒓𝒆𝒇𝒐𝒓𝒆, 𝒂𝒇𝒕𝒆𝒓 𝒑𝒐𝒑 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒔𝒕𝒂𝒄𝒌 𝒘𝒆 𝒉𝒂𝒗𝒆: </h3>

![Screenshot (563)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/f5a81655-9158-403d-8555-e8aeb3dfce5f)
  
<h3> 𝑵𝒐𝒘, 𝒂𝒈𝒂𝒊𝒏 𝒑𝒐𝒑() → `(` .</h3>
<h3>𝑻𝒉𝒊𝒔 𝒑𝒐𝒑 𝒇𝒖𝒏𝒄𝒕𝒊𝒐𝒏 𝒘𝒊𝒍𝒍 𝒎𝒂𝒌𝒆 𝒔𝒕𝒂𝒌𝒆 𝒆𝒎𝒑𝒕𝒚: </h3>
<h3>𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟎 − 𝟏 = −𝟏  </h3>
  
![Screenshot (564)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/2e538659-1310-4219-b90b-b73297627c21)

<h3>𝑨𝒏𝒅 𝒕𝒉𝒆𝒏 𝒊 + + = 𝒊 + 𝟏 = 𝟒 + 𝟏 = 𝟓 </h3>
<h3>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + </h3>
 
</ul>
  
<h2></h2>  
<h2><ins>  𝟖) 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 ` ∗ ` </ins></h2>
  
<ul>
  
 ![Screenshot (565)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/5e435bb2-cd89-4bb5-8951-d0d6402fbef3)
  
<h3>  𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅(𝒊𝒏𝒇𝒊𝒙[𝟓] = ` ∗ `) = 𝟎[𝑭𝒂𝒍𝒔𝒆], 𝒉𝒆𝒏𝒄𝒆 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕 𝒓𝒖𝒏𝒔. </h3>
<h3>𝒑𝒓𝒆𝒇𝒊𝒙(𝒊𝒏𝒇𝒊𝒙[𝟓] = ` ∗ `) = 𝟐 > 𝒑𝒓𝒆(𝒔𝒕. 𝒔[𝒔𝒕. 𝒕𝒐𝒑]) = −𝟏 </h3>
<h3>  𝑷𝒖𝒔𝒉 → ∗ </h3>
  
![Screenshot (566)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/0b6e329a-8d5e-458a-a7d4-ce2815549da1)
  
<h3>  𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = −𝟏 + 𝟏 = 𝟎 𝒂𝒏𝒅 𝒊 = 𝒊 + + = 𝟓 + 𝟏 = 𝟔</h3>

</ul>

<h2></h2>  
<h2><ins>  𝟗) 𝑵𝒐𝒘 𝒘𝒆 𝒄𝒂𝒏 𝒓𝒆𝒍𝒂𝒕𝒆 𝒉𝒐𝒘 (𝒄^𝒅)𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒓𝒐𝒄𝒆𝒔𝒔𝒆𝒅. </ins></h2>
  
 <ul>
   
<h3> <ins>  𝟏𝒔𝒕 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒑𝒖𝒔𝒉 ( </ins></h3>
 
<ul>
  
![Screenshot (567)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/865cdc90-6678-42ac-8620-17c9d82c2896)
   
<h3><li>𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = 𝟎 + 𝟏 = 𝟏 𝒂𝒏𝒅 𝒊 = 𝒊 + 𝟏 = 𝟔 + 𝟏 = 𝟕.</li></h3>

</ul>
   
<h3><ins> 𝟐𝒏𝒅 𝒇𝒐𝒓 𝒄 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒖𝒕 𝒊𝒏𝒔𝒊𝒅𝒆 𝒑𝒐𝒔𝒇𝒊𝒙 𝒂𝒓𝒓𝒂𝒚:</ins></h3>

 <ul>
   
<h3><li>𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝟑] = 𝒊𝒏𝒇𝒊𝒙[𝟕] = 𝒄</li></h3>
<h3><li>𝒊 = 𝒊 + 𝟏 = 𝟕 + 𝟏 = 𝟖</li></h3>
<h3><li>𝒋 = 𝒋 + 𝟏 = 𝟑 + 𝟏 = 𝟒</li></h3>
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + 𝒄</li></h3>
   
</ul>

<h3><ins> 𝟑𝒓𝒅 𝒇𝒐𝒓 ^ ,𝒊𝒕 𝒘𝒊𝒍𝒍 𝒂𝒈𝒂𝒊𝒏 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒖𝒔𝒉𝒆𝒅 𝒊𝒏𝒔𝒊𝒅𝒆 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌   </ins></h3>
   
<ul> 
  
  ![Screenshot (568)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/76586ec3-6661-4710-9bc9-f8968fd1ed1f)

  
 <h3><li>𝒕𝒐𝒑 = 𝒕𝒐𝒑 + 𝟏 = 𝟏 + 𝟏 = 𝟐 𝒂𝒏𝒅 𝒊 = 𝒊 + 𝟏 = 𝟖 + 𝟏 = 𝟗.</li></h3> 
  
</ul>  
   
 <h3><ins> 𝟒𝒓𝒕𝒉 𝒇𝒐𝒓 𝒅 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒖𝒕 𝒊𝒏𝒔𝒊𝒅𝒆 𝒑𝒐𝒔𝒇𝒊𝒙 𝒂𝒓𝒓𝒂𝒚:</ins></h3>  
   
<ul> 
  
<h3><li>𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝟒] = 𝒊𝒏𝒇𝒊𝒙[𝟗] = 𝒅</li></h3> 
<h3><li>𝒊 = 𝒊 + 𝟏 = 𝟗 + 𝟏 = 𝟏𝟎</li></h3> 
<h3><li>𝒋 = 𝒋 + 𝟏 = 𝟒 + 𝟏 = 𝟓</li></h3> 
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + 𝒄𝒅 </li></h3> 
  
</ul>  
   
 <h3><ins> 𝟓𝒕𝒉 𝒇𝒐𝒓 `(` ∶ </ins></h3> 
   
<ul> 
  
<h3><li>𝑬𝒗𝒆𝒓𝒚𝒕𝒉𝒊𝒏𝒈 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒇𝒓𝒐𝒎 𝒔𝒕𝒂𝒄𝒌 𝒍𝒆𝒔𝒔 𝒕𝒉𝒂𝒏 `(` ∶</li></h3> 
<h3><li>𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝒋 = 𝟓] = 𝒑𝒐𝒑() = `^` ;</li></h3> 
<h3><li>𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟐 − 𝟏 = 𝟏</li></h3> 
<h3><li>𝒋 = 𝒋 + 𝟏 = 𝟓 + 𝟏 = 𝟔</li></h3> 
  
![Screenshot (569)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/cc110019-052f-4b92-b049-f8ff085ea13f)
  
<h3><li>𝑨𝒏𝒅 𝒕𝒉𝒆𝒏 `(` 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕.</li></h3> 
<h3><li>𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟏 − 𝟏 = 𝟎.</li></h3> 
  
  ![Screenshot (570)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/f19273f3-97bd-4cf7-9175-3000eb251e1e)

<h3><li>  𝒊 = 𝒊 + 𝟏 = 𝟏𝟎 + 𝟏 = 𝟏𝟏.</li></h3> 
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + 𝒄𝒅^</li></h3> 
  
  
</ul>    

<h2></h2>  
<h2><ins> 𝟏𝟎)  𝑵𝒐𝒘 𝒇𝒐𝒓 `*` 𝒊𝒏 𝑺𝒕𝒂𝒄𝒌.  </ins></h2>
   
   
<ul>

<h3>𝑵𝒐𝒘 𝒊𝒇 𝒘𝒆 𝒔𝒆𝒆 𝒕𝒉𝒆 𝑺𝒕𝒂𝒄𝒌` ∗ ` 𝒊𝒔 𝒍𝒆𝒇𝒕 𝒕𝒐 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕. 𝑵𝒐𝒘
𝒕𝒉𝒆𝒓𝒆 𝒊𝒔 𝒏𝒐 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔 𝒍𝒆𝒇𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒂𝒓𝒊𝒕𝒉𝒎𝒆𝒕𝒊𝒄 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.
𝑯𝒆𝒏𝒄𝒆, 𝒕𝒉𝒆𝒓𝒆 𝒎𝒖𝒔𝒕 𝒃𝒆 𝒂 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏 𝒘𝒉𝒊𝒄𝒉 𝒘𝒊𝒍𝒍 𝒑𝒐𝒑 𝒐𝒖𝒕 𝒕𝒉𝒆
𝒍𝒆𝒇𝒕 𝒐𝒗𝒆𝒓 𝒐𝒇 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒉𝒆𝒍𝒑 𝒊𝒏 𝒑𝒖𝒔𝒉𝒊𝒏𝒈 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒏 𝒔𝒕𝒂𝒄𝒌
𝒘𝒉𝒆𝒏 𝒕𝒉𝒆𝒓𝒆 𝒊𝒔 𝒏𝒐 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔 𝒊𝒏 𝒕𝒉𝒆 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 ∶</h3>
  
![Screenshot (571)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/42cb2190-3766-4103-89a4-3db0d0841ecb)
  
<h3> 𝑰𝒇 𝒚𝒐𝒖 𝒔𝒆𝒆 𝒕𝒉𝒆 𝒘𝒉𝒐𝒍𝒆 𝒂𝒓𝒊𝒕𝒉𝒎𝒆𝒕𝒊𝒄 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏:</h3>
  
<ul>
  
<h3>(𝒂 + 𝒃) ∗ (𝒄^𝒅)/𝒆</h3>
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒏𝒐𝒕 𝒐𝒏𝒍𝒚 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒕𝒐 𝒑𝒐𝒑 ∗ 𝒃𝒖𝒕 𝒂𝒍𝒔𝒐 𝒎𝒖𝒔𝒕 𝒑𝒖𝒔𝒉 / .</li></h3>
<h3><li>𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅(𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟏𝟏] = /) = 𝟎 𝒉𝒆𝒏𝒄𝒆 𝒎𝒐𝒗𝒆 𝒕𝒐 𝒆𝒍𝒔𝒆 𝒑𝒂𝒓𝒕.</li></h3>
<h3><li>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟏𝟏] = /) = 𝟐 ≤ 𝒑𝒓𝒆(𝒔𝒕. 𝒔[𝒔𝒕. 𝒕𝒐𝒑]= 𝒔𝒕. 𝒔[𝟎] =∗ = 𝟐) = 𝒕𝒓𝒖𝒆</li></h3>
<h3><li>!𝒊𝒔𝑬𝒎𝒑𝒕𝒚(𝒔𝒕) = 𝒕𝒓𝒖𝒆</li></h3>
<h3><li>𝑨𝒏𝒅 𝒕𝒐𝒑 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒅𝒐𝒆𝒔𝒏𝒐𝒕 𝒄𝒐𝒏𝒕𝒂𝒊𝒏 ( 𝒂𝒏𝒅 ) 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔.</li></h3>
  
<h3><li>𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝒋 = 𝟔] = 𝒑𝒐𝒑() =∗</li></h3>
<h3><li>𝒋 + += 𝒋 + 𝟏 = 𝟔 + 𝟏 = 𝟕</li></h3>
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + 𝒄𝒅^ ∗ </li></h3>

</ul>
  
<h3>𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟎 − 𝟏 = −𝟏 𝒊. 𝒆. 𝒆𝒎𝒑𝒕𝒚</h3>
<h3>𝑵𝒐𝒘 𝒄𝒐𝒎𝒊𝒏𝒈 𝒐𝒖𝒕 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒍𝒐𝒐𝒑 , 𝒘𝒆 𝒈𝒆𝒕:</h3>
  
<ul>  
<h3><li>𝑷𝒖𝒔𝒉 → / 𝒊𝒏𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</li></h3>
<h3><li>𝒕𝒐𝒑 = −𝟏 + 𝟏 = 𝟎 </li> </h3>
  
</ul>
  
![Screenshot (573)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/d0e6d765-2af6-4f7c-ae75-0b87aa8bd162)
  
 <h3>𝒊 = 𝒊 + += 𝒊 + 𝟏 = 𝟏𝟏 + 𝟏 = 𝟏𝟐</h3>
 
</ul>
   

<h2></h2>  
<h2><ins> 𝟏𝟏) 𝑵𝒐𝒘 𝒘𝒆 𝒉𝒂𝒗𝒆 `𝒆` 𝒍𝒆𝒇𝒕 𝒇𝒐𝒓 𝒂𝒔𝒔𝒊𝒈𝒏𝒊𝒏𝒈 𝒊𝒕 𝒕𝒐 𝒂𝒓𝒓𝒂𝒚. </ins></h2>  
   
<ul>
 
 ![Screenshot (574)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/4abb222f-3985-490a-b440-a9b42e452953)
  
 <h3><li>𝑵𝒐𝒘 𝒊𝒔𝑶𝒑𝒆𝒓𝒂𝒏𝒅(𝒊𝒏𝒇𝒊𝒙[𝒊] = 𝒊𝒏𝒇𝒊𝒙[𝟏𝟐]) = 𝟏(𝒕𝒓𝒖𝒆)𝒘𝒊𝒍𝒍 𝒆𝒏𝒕𝒆𝒓 𝒊𝒇′𝒔 𝒃𝒐𝒅𝒚.</li></h3>
 <h3><li>𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝒋 = 𝟕] = 𝒊𝒏𝒇𝒊𝒙 [𝒊 = 𝟏𝟐] = 𝒆</li></h3>
 <h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + 𝒄𝒅^ ∗ 𝒆 </li></h3>
 <h3><li>𝒋 = 𝒋 + 𝟏 = 𝟕 + 𝟏 = 𝟖</li></h3>
 <h3><li>𝒊 = 𝒊 + 𝟏 = 𝟏𝟐 + 𝟏 = 𝟏𝟑</li></h3>
 
  
</ul>  
   
<h2></h2>  
<h2><ins> 𝟏𝟐) 𝑵𝒐𝒘 𝒐𝒏𝒆 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒍𝒆𝒇𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒕𝒐 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒊. 𝒆./ </ins></h2>  
   
<ul>  
  
  ![Screenshot (576)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/ade517d5-3651-4ac2-a2b6-b1069853b3e4)
  
<h3><li>  𝑾𝒆 𝒉𝒂𝒗𝒆 𝒂𝒍𝒓𝒆𝒂𝒅𝒚 𝒇𝒊𝒏𝒊𝒔𝒉𝒆𝒅 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏 `𝒊` 𝒕𝒐 𝒃𝒆 𝒄𝒐𝒎𝒑𝒂𝒓𝒆𝒅:
𝒊. 𝒆. 𝒘𝒉𝒂𝒕 𝒆𝒗𝒆𝒓 𝒍𝒆𝒇𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒏𝒐𝒘, 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒕𝒊𝒍𝒍 𝒊𝒕𝒔 𝒆𝒎𝒑𝒕𝒚.</li></h3>
  
<ul>
  
<h3><li>𝑷𝒐𝒔𝒕𝒇𝒊𝒙[𝒋 = 𝟖] = 𝒑𝒐𝒑() =/ </li></h3>
<h3><li>𝒕𝒐𝒑 = 𝒕𝒐𝒑 − 𝟏 = 𝟎 − 𝟏 = −𝟏 𝒊. 𝒆. 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒆𝒎𝒑𝒕𝒚. </li></h3>
<h3><li>𝒋 = 𝒋 + 𝟏 = 𝟗 </li></h3>
  
</ul> 
  
<h3>𝑨𝒏𝒅 𝟗𝒕𝒉 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 𝒂 𝒏𝒖𝒍𝒍 𝒕𝒆𝒓𝒎𝒊𝒏𝒂𝒕𝒐𝒓 ‘\𝟎’.
𝑰𝒕 𝒊𝒎𝒑𝒍𝒊𝒆𝒔 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒇𝒊𝒏𝒊𝒔𝒉𝒆𝒅 𝒐𝒖𝒓 𝒑𝒐𝒔𝒕 𝒇𝒊𝒙 𝒄𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏 𝒐𝒓 𝒆𝒏𝒅
𝒐𝒇 𝒔𝒕𝒓𝒊𝒏𝒈. 𝑵𝒖𝒍𝒍 𝒕𝒆𝒎𝒊𝒏𝒂𝒕𝒐𝒓 𝒎𝒂𝒓𝒌𝒔 𝒕𝒉𝒆 𝒆𝒏𝒅 𝒐𝒇 𝒕𝒉𝒆 𝒔𝒕𝒓𝒊𝒏𝒈 .</h3>
  
<ul>
  
<h3><li>𝑯𝒆𝒏𝒄𝒆,𝒑𝒐𝒔𝒕𝒇𝒊𝒙[𝒋 = 𝟗] = ’/𝟎’ .</li></h3>
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒇𝒐𝒓𝒎𝒂𝒕𝒊𝒐𝒏: 𝒂𝒃 + 𝒄𝒅^ ∗ 𝒆/ </li></h3>
<h3><li>𝑵𝒐𝒘, 𝒇𝒓𝒆𝒆 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒎𝒆𝒎𝒐𝒓𝒚 = 𝒇𝒓𝒆𝒆(𝒔𝒕. 𝒔)𝒂𝒏𝒅 𝒓𝒆𝒕𝒖𝒓𝒏 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕 𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>

</ul> 
  
</ul> 
   
 <h2></h2>  
<h2 align="Center">𝑵𝒐𝒘, 𝒒𝒖𝒆𝒔𝒕𝒊𝒐𝒏 𝒎𝒂𝒚 𝒂𝒓𝒊𝒔𝒆 𝒐𝒏:</h2>
   
 <ul>
   
 ![Screenshot (579)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/a395cfea-1543-4a16-ac1e-45521c139c75)
  
 <h3>𝑵𝒐𝒘 𝒄𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝒕𝒉𝒓𝒆𝒆 𝒂𝒓𝒊𝒕𝒉𝒎𝒆𝒕𝒊𝒄 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏:</h3>
   
 <ul>
    
 <h3><li>𝟏. (𝒂 + 𝒃)/(𝒄 − 𝒃) + 𝒆</li></h3>
 <h3><li>𝟐. (𝒂 + 𝒃) + (𝒄 − 𝒃) + 𝒆</li></h3>
 <h3><li> 𝟑. (𝒂 + 𝒃) + (𝒄 − 𝒃)/𝒆</li></h3>
 
    
 </ul> 
   
<h3 align="Center">  <ins> 𝑪𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝟏𝒔𝒕 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 ∶</ins></h3>
   
<ul>
 
<h3>𝒘𝒆 𝒌𝒏𝒐𝒘 𝒉𝒐𝒘 (𝒂 + 𝒃)𝒂𝒏𝒅 (𝒄 − 𝒃)𝒘𝒊𝒍𝒍 𝒃𝒆 𝒆𝒙𝒆𝒄𝒖𝒕𝒆𝒅. 𝑻𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒓𝒆𝒎𝒂𝒊𝒏𝒔:</h3>
  
![Screenshot (580)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/cd28aea8-e260-4328-9af9-370c95ac5a7d)
  
<h3><li>𝑨𝒏𝒅 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒃 + 𝒄𝒃 − 𝒂𝒔 𝒉𝒂𝒍𝒇𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 𝒂 𝒄𝒐𝒎𝒑𝒂𝒓𝒊𝒔𝒐𝒏 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 + 𝒂𝒏𝒅 /.</li></h3>
<h3><li>𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊 = 𝟏𝟏] =′+ ′) = 𝟏 ≤ 𝒑𝒓𝒆(𝒔𝒕[𝒔. 𝒕𝒐𝒑] =′/′)= 𝟐 𝒊𝒔 𝒕𝒓𝒖𝒆.</li></h3>
<h3><li>𝑻𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒍𝒐𝒐𝒑 𝒓𝒖𝒏𝒔 𝒃𝒂𝒔𝒆𝒅 𝒐𝒏 𝒕𝒉𝒊𝒔 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏(𝒂𝒔 𝒕𝒉𝒊𝒔 𝒔𝒂𝒕𝒊𝒔𝒇𝒚 𝒕𝒉𝒆 𝒓𝒆𝒒𝒖𝒊𝒓𝒆𝒎𝒆𝒏𝒕). </li></h3> 
  
  
  
</ul>  
   
<br> 
   
<h3 align="Center">  <ins> 𝑪𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝟐𝒏𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 ∶  </ins></h3>

<ul> 
  
 <h3>𝒘𝒆 𝒌𝒏𝒐𝒘 𝒉𝒐𝒘 (𝒂 + 𝒃)𝒂𝒏𝒅 (𝒄 − 𝒃)𝒘𝒊𝒍𝒍 𝒃𝒆 𝒆𝒙𝒆𝒄𝒖𝒕𝒆𝒅.𝑻𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒓𝒆𝒎𝒂𝒊𝒏𝒔:</h3>    
 
  ![Screenshot (581)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/41138fe4-b413-4cf6-9c58-a7154dde7864)

<h3><li>𝑨𝒏𝒅 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒃 + 𝒄𝒃 − 𝒂𝒔 𝒉𝒂𝒍𝒇𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏. </li></h3> 
<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 𝒂 𝒄𝒐𝒎𝒑𝒂𝒓𝒊𝒔𝒐𝒏 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 + 𝒂𝒏𝒅 /.𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊 = 𝟏𝟏] =′+ ′) = 𝟏 ≤ 𝒑𝒓𝒆(𝒔𝒕[𝒔. 𝒕𝒐𝒑] =′ +′)= 𝟏 𝒊𝒔 𝒕𝒓𝒖𝒆.</li></h3>
<h3><li>𝑻𝒉𝒆 𝒂𝒃𝒐𝒗𝒆 𝒍𝒐𝒐𝒑 𝒓𝒖𝒏𝒔 𝒃𝒂𝒔𝒆𝒅 𝒐𝒏 𝒕𝒉𝒊𝒔 𝒄𝒐𝒏𝒅𝒊𝒕𝒊𝒐𝒏(𝒂𝒔 𝒕𝒉𝒊𝒔 𝒔𝒂𝒕𝒊𝒔𝒇𝒚 𝒕𝒉𝒆 𝒓𝒆𝒒𝒖𝒊𝒓𝒆𝒎𝒆𝒏𝒕) .</li></h3>
  
</ul>  
   
<br> 
   
<h3 align="Center">  <ins> 𝑪𝒐𝒏𝒔𝒊𝒅𝒆𝒓 𝟑𝒓𝒅 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 ∶  </ins></h3>
   
 <ul>
   
<h3> 𝒘𝒆 𝒌𝒏𝒐𝒘 𝒉𝒐𝒘 (𝒂 + 𝒃)𝒂𝒏𝒅 (𝒄 − 𝒃)𝒘𝒊𝒍𝒍 𝒃𝒆 𝒆𝒙𝒆𝒄𝒖𝒕𝒆𝒅.𝑻𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒓𝒆𝒎𝒂𝒊𝒏𝒔: </h3>   
   
 ![Screenshot (582)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/e218add4-3644-45eb-8a6f-6b14684f3306)
   
 <h3><li>𝑨𝒏𝒅 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒂𝒃 + 𝒄𝒃 − 𝒂𝒔 𝒉𝒂𝒍𝒇𝒄𝒐𝒏𝒗𝒆𝒓𝒕𝒆𝒅 𝒑𝒐𝒔𝒕𝒇𝒊𝒙
𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><li>𝑵𝒐𝒘 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒉𝒂𝒗𝒆 𝒂 𝒄𝒐𝒎𝒑𝒂𝒓𝒊𝒔𝒐𝒏 𝒃𝒆𝒕𝒘𝒆𝒆𝒏 + 𝒂𝒏𝒅 / :𝒑𝒓𝒆(𝒊𝒏𝒇𝒊𝒙[𝒊 = 𝟏𝟏] =′/′) = 𝟐 ≤ 𝒑𝒓𝒆(𝒔𝒕[𝒔. 𝒕𝒐𝒑] =′ +′)= 𝟏 𝒊𝒔 𝒇𝒂𝒍𝒔𝒆.</li></h3>
<h3><li>𝑾𝒉𝒂𝒕 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒅𝒐 𝒊𝒔 ∶ 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒑𝒖𝒔𝒉 𝒕𝒉𝒆 𝒏𝒆𝒙𝒕 𝒆𝒍𝒆𝒎𝒆𝒏𝒕 𝒊𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 ∶</li></h3>
   
 ![Screenshot (584)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/daf9b290-d304-4048-b7e8-36b2cc0b359f)
  
 <h3><li> 𝑵𝒐𝒘 𝒔𝒕𝒂𝒄𝒌 𝒘𝒊𝒍𝒍 𝒃𝒆 ∶</li></h3>
   
 ![Screenshot (585)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/914ae82b-a7c9-45fa-a684-ac9b455c727d)
   
 <h3><li>𝑨𝒇𝒕𝒆𝒓 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒘𝒆 𝒘𝒊𝒍𝒍 𝒈𝒆𝒕:</li></h3>
   
![Screenshot (586)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/e9f0df0f-daa9-4450-94e8-0d1e69a48c71)
 
<h3> 𝒂𝒃 + 𝒄𝒃 − 𝒆</h3>
  
<h3><li>  𝑨𝒏𝒅 𝒕𝒉𝒆𝒏 𝒘𝒆 𝒉𝒂𝒗𝒆 𝒇𝒊𝒏𝒊𝒔𝒉𝒆𝒅 𝒆𝒍𝒆𝒎𝒆𝒏𝒕𝒔 𝒊𝒏 `𝒊` 𝒕𝒐 𝒃𝒆 𝒄𝒐𝒎𝒑𝒂𝒓𝒆𝒅.𝑯𝒆𝒏𝒄𝒆 𝒆𝒗𝒆𝒓𝒚𝒕𝒉𝒊𝒏𝒈 𝒘𝒊𝒍𝒍 𝒃𝒆 𝒑𝒐𝒑𝒑𝒆𝒅 𝒐𝒖𝒕 𝒐𝒏𝒆 𝒃𝒚 𝒐𝒏𝒆:</li></h3>

<ul>
 
<h3><li> <ins> 𝟏. 𝒑𝒐𝒑 → / </ins></li></h3>
  
 <ul> 
  
![Screenshot (587)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/c51b326c-1bd2-4374-875c-1a055878b508)
  
![Screenshot (588)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/4f49af7f-2251-45c3-af52-06ed6ad4d9fa)

<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕 𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒏𝒐𝒘: 𝒂𝒃 + 𝒄𝒃 − 𝒆/</li></h3>
 
</ul>
  
 <h3><li> <ins> 𝟐. 𝒑𝒐𝒑 → + </ins></li></h3>
  
  <ul>
    
  ![Screenshot (589)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/82919334-7040-4ed9-8ed8-ec67048b9139)
  
  ![Screenshot (590)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/b8e6c57a-78be-4fab-b0e2-9178810bc67d)
    
 <h3><li> 𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕 𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒏𝒐𝒘: 𝒂𝒃 + 𝒄𝒃 − 𝒆/+</li></h3>
  

  </ul>  
  
</ul>  
   
   
   
 </ul>  
   
   
 </ul>  
  
</ul>

<h1></h1>  
  
<h1 align="Center">𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔 𝒐𝒇 𝑨𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎 </h1>
  
<ul>
  
<h3>𝑨𝒇𝒕𝒆𝒓 𝒂𝒏𝒂𝒍𝒚𝒔𝒊𝒏𝒈 𝒕𝒉𝒆 𝒘𝒐𝒓𝒌𝒊𝒏𝒈𝒔 𝒐𝒇 𝒕𝒉𝒆 𝒑𝒓𝒐𝒈𝒓𝒂𝒎 𝒘𝒆 𝒄𝒂𝒏 𝒈𝒆𝒏𝒆𝒓𝒂𝒕𝒆 𝒕𝒉𝒆 𝒂𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎𝒊𝒄 𝒔𝒕𝒓𝒖𝒄𝒕𝒖𝒓𝒆 ∶</h3>
<br> 
<h3 align="Center"><ins>𝑰𝒏𝒇𝒊𝒙 𝑻𝒐 𝑷𝒐𝒔𝒕𝒇𝒊𝒙 𝑨𝒍𝒈𝒐𝒓𝒊𝒕𝒉𝒎</ins></h3>
<br>  
<h3>𝑺𝒕𝒆𝒑 𝟏: 𝑨𝒅𝒅 '\0' 𝒕𝒐 𝒕𝒉𝒆 𝒆𝒏𝒅 𝒐𝒇 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏</h3>
<h3>𝑺𝒕𝒆𝒑 𝟐: 𝑷𝒖𝒔𝒉 ( 𝒐𝒏 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌</h3>
<h3>𝑺𝒕𝒆𝒑 𝟑: 𝑹𝒆𝒑𝒆𝒂𝒕 𝒖𝒏𝒕𝒊𝒍 𝒆𝒂𝒄𝒉 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒏 𝒕𝒉𝒆 𝒊𝒏𝒇𝒊𝒙 𝒏𝒐𝒕𝒂𝒕𝒊𝒐𝒏 𝒊𝒔 𝒔𝒄𝒂𝒏𝒏𝒆𝒅.</h3>

<ul>  
<h3><li>𝑰𝒇 𝒂 `(` 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅, 𝒑𝒖𝒔𝒉 𝒊𝒕 𝒐𝒏 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</li></h3>
<h3><li>𝑰𝒇 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒏𝒅 ( 𝒘𝒉𝒆𝒕𝒉𝒆𝒓 𝒂 𝒅𝒊𝒈𝒊𝒕 𝒐𝒓 𝒂 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓) 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅,𝒂𝒅𝒅 𝒊𝒕 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><li>𝑰𝒇 𝒂 `)` 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅, 𝒕𝒉𝒆𝒏:</li></h3>

<ul>
  
<h3><li> 𝒂.𝑹𝒆𝒑𝒆𝒂𝒕𝒆𝒅𝒍𝒚 𝒑𝒐𝒑 𝒇𝒓𝒐𝒎 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒖𝒏𝒕𝒊𝒍 𝒂 `(` 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅.</li></h3>
<h3><li>𝒃. 𝑫𝒊𝒔𝒄𝒂𝒓𝒅 𝒕𝒉𝒆 ( . 𝑻𝒉𝒂𝒕 𝒊𝒔, 𝒓𝒆𝒎𝒐𝒗𝒆 𝒕𝒉𝒆 `(` 𝒇𝒓𝒐𝒎 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒅𝒐 𝒏𝒐𝒕 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3><ins>𝑰𝒇 𝒂𝒏 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒊𝒔 𝒆𝒏𝒄𝒐𝒖𝒏𝒕𝒆𝒓𝒆𝒅,</ins></h3>  
<ul>  
<h3><li>𝒂.𝑹𝒆𝒑𝒆𝒂𝒕𝒆𝒅𝒍𝒚 𝒑𝒐𝒑 𝒇𝒓𝒐𝒎 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅 𝒆𝒂𝒄𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 (𝒑𝒐𝒑𝒑𝒆𝒅 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌) 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒘𝒉𝒊𝒄𝒉 𝒉𝒂𝒔 𝒕𝒉𝒆 𝒔𝒂𝒎𝒆 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 𝒐𝒓 𝒂 𝒉𝒊𝒈𝒉𝒆𝒓 𝒑𝒓𝒆𝒄𝒆𝒅𝒆𝒏𝒄𝒆 .</li></h3>
<h3><li>𝒃.𝑷𝒖𝒔𝒉 𝒕𝒉𝒆 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓 𝒕𝒐 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌.</li></h3>
</ul>   
<h3><li>[𝑬𝑵𝑫 𝑶𝑭 𝑰𝑭]</li></h3>
 </ul>
</ul>  
<h3>𝑺𝒕𝒆𝒑 𝟒: 𝑹𝒆𝒑𝒆𝒂𝒕𝒆𝒅𝒍𝒚 𝒑𝒐𝒑 𝒇𝒓𝒐𝒎 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒂𝒏𝒅 𝒂𝒅𝒅 𝒊𝒕 𝒕𝒐 𝒕𝒉𝒆 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏 𝒖𝒏𝒕𝒊𝒍 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒆𝒎𝒑𝒕𝒚.</h3>
<h3>𝑺𝒕𝒆𝒑 𝟓: 𝑬𝑿𝑰𝑻 </h3>
  
  
</ul>  
  
<h1></h1>  
  
<h1 align="Center">𝑻𝒊𝒎𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔 </h1>  
  
<ul>  
  
<h3>𝑭𝒐𝒓 𝒑𝒖𝒔𝒉 𝒂𝒏𝒅 𝒑𝒐𝒑 𝒘𝒆 𝒌𝒏𝒐𝒘 𝒊𝒕 𝒘𝒊𝒍𝒍 𝒃𝒆 𝑶(𝟏) 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 .𝑩𝒖𝒕 𝒇𝒐𝒓 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒂𝒅𝒅𝒊𝒕𝒊𝒐𝒏 𝒊𝒏 𝒂𝒏 𝒂𝒓𝒓𝒂𝒚.</h3>
<h3>𝑾𝒆 𝒔𝒆𝒆 𝒆𝒂𝒄𝒉 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓 𝒊𝒔 𝒂𝒅𝒅𝒆𝒅 𝟏 𝒕𝒊𝒎𝒆 𝒄𝒐𝒏𝒔𝒖𝒎𝒊𝒏𝒈 𝟏 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒕𝒊𝒎𝒆:</h3> 
  
![Screenshot (591)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/0b1a0506-f39d-49ea-8ac7-ef5f0d9de70f)
  
<h3><li>𝒊𝒇 𝒕𝒉𝒆𝒓𝒆 𝒊𝒔 𝒏𝒐 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 𝒏 𝒖𝒏𝒊𝒕 𝒕𝒊𝒎𝒆 𝒕𝒐 𝒄𝒐𝒎𝒑𝒍𝒆𝒕𝒆.</li></h3>
<h3><li>𝒊𝒇 𝟏 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔 𝒕𝒉𝒆𝒏 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 𝒏 − 𝟏 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒕𝒊𝒎𝒆 𝒕𝒐 𝒄𝒐𝒎𝒑𝒍𝒆𝒕𝒆.</li></h3>
<h3><li>𝒊𝒇 𝟐 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔 𝒕𝒉𝒆𝒏 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 𝒏 − 𝟐 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒕𝒊𝒎𝒆 𝒕𝒐 𝒄𝒐𝒎𝒑𝒍𝒆𝒕𝒆.</li></h3>
<h3><li>𝒊𝒇 𝒌 𝒏𝒐. 𝒐𝒇 𝒑𝒂𝒓𝒆𝒏𝒕𝒉𝒆𝒔𝒊𝒔 𝒕𝒉𝒆𝒏 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 𝒏 − 𝒌 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒕𝒊𝒎𝒆 𝒕𝒐 𝒄𝒐𝒎𝒑𝒍𝒆𝒕𝒆, 𝒘𝒉𝒆𝒓𝒆 𝒌 𝒊𝒔 𝒄𝒐𝒏𝒔𝒕𝒂𝒏𝒕 .</li></h3>
<h3><li>𝑨𝒍𝒔𝒐 𝒊𝒇 𝒘𝒆 𝒄𝒐𝒎𝒑𝒂𝒓𝒆 𝒊𝒕 𝒘𝒊𝒕𝒉 𝒎𝒆𝒎𝒐𝒓𝒚 = 𝒑𝒐𝒔𝒕𝒇𝒊𝒇𝒊𝒙 𝒕𝒂𝒌𝒆𝒔 𝒂 𝒔𝒊𝒏𝒈𝒍𝒆 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒎𝒆𝒎𝒐𝒓𝒚 𝒂𝒏𝒅 𝒓𝒖𝒏𝒔 𝒖𝒑𝒕𝒐 𝒏 𝒕𝒊𝒎𝒆𝒔 𝒐𝒓 𝒏 − 𝒌 𝒕𝒊𝒎𝒆𝒔 𝒕𝒐 𝒈𝒆𝒏𝒆𝒓𝒂𝒕𝒆 𝒂 𝒑𝒐𝒔𝒕𝒇𝒊𝒙 𝒆𝒙𝒑𝒓𝒆𝒔𝒔𝒊𝒐𝒏.</li></h3>
<h3>𝑯𝒆𝒏𝒄𝒆 𝒑𝒐𝒔𝒕 𝒇𝒊𝒙 𝒕𝒂𝒌𝒆 𝑶(𝒏)𝒕𝒊𝒎𝒆𝒔 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚.</h3>
  
  ![Screenshot (592)](https://github.com/AvinandanBose/Infix_To_Postfix_Conversion/assets/38869235/00dd50c2-df84-4713-8bc7-f2a86403b452)

  
</ul> 
  
 <h1></h1>  
  
<h1 align="Center">𝑺𝒑𝒂𝒄𝒆 𝑪𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚 𝑨𝒏𝒂𝒍𝒚𝒔𝒊𝒔 </h1>  
  
<ul>
  
<h3><li>𝑰𝒇 𝒘𝒆 𝒉𝒂𝒗𝒆 `𝒌` 𝒏𝒐. 𝒐𝒇 𝒄𝒉𝒂𝒓𝒂𝒄𝒕𝒆𝒓𝒔 𝒂𝒏𝒅 𝒊𝒏 𝒘𝒉𝒊𝒄𝒉 𝒘𝒆 𝒉𝒂𝒗𝒆 `𝒏` 𝒏𝒖𝒎𝒃𝒆𝒓 𝒐𝒇 𝒐𝒑𝒆𝒓𝒂𝒕𝒐𝒓𝒔.</li></h3>
<h3><li>𝑾𝒆 𝒌𝒏𝒐𝒘 𝒘𝒉𝒆𝒏 𝒘𝒆 𝒂𝒅𝒅 𝒂𝒏𝒚𝒕𝒉𝒊𝒏𝒈 𝒊𝒏 𝒂𝒓𝒓𝒂𝒚 𝒊𝒕 𝒕𝒂𝒌𝒆𝒔 𝑶(𝟏), 𝒊. 𝒆. 𝒔𝒂𝒎𝒆 𝒖𝒏𝒊𝒕 𝒐𝒇 𝒔𝒑𝒂𝒄𝒆 𝒖𝒔𝒆𝒅 𝒕𝒐 𝒊𝒏𝒑𝒖𝒕 𝒅𝒂𝒕𝒂 𝒊𝒏 𝒕𝒉𝒆 𝒂𝒖𝒙𝒊𝒍𝒊𝒂𝒓𝒚 𝒔𝒑𝒂𝒄𝒆 𝒄𝒓𝒆𝒂𝒕𝒆𝒅 𝒇𝒐𝒓 𝒂𝒓𝒓𝒂𝒚.</li></h3>
<h3><li>𝑾𝒉𝒆𝒓𝒆 𝒂𝒔 𝒏 𝒕𝒊𝒎𝒆𝒔 𝒕𝒉𝒆 𝒔𝒕𝒂𝒄𝒌 𝒊𝒔 𝒖𝒔𝒆𝒅 𝒇𝒐𝒓 𝒑𝒖𝒔𝒉 𝒐𝒑𝒆𝒓𝒂𝒕𝒊𝒐𝒏 𝒄𝒐𝒏𝒔𝒖𝒎𝒊𝒏𝒈 `𝒏` 𝒔𝒑𝒂𝒄𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚.</li></h3>
<h3><li>𝑯𝒆𝒏𝒄𝒆 𝒊𝒇 𝒘𝒆 𝒔𝒖𝒎 𝒖𝒑 𝒕𝒉𝒆𝒏 𝒘𝒆 𝒈𝒆𝒕: 𝑶(𝟏) + 𝑶(𝒏) = 𝑶(𝒏) 𝒔𝒑𝒂𝒄𝒆 𝒄𝒐𝒎𝒑𝒍𝒆𝒙𝒊𝒕𝒚.</li></h3>  
  
  
</ul>  
<h2> </h2>
<h1> 👉 <a href="https://github.com/AvinandanBose/CPLUSPLUS_DataStructure"> 𝑪++ - 𝑰𝒏𝒇𝒊𝒙 𝒕𝒐 𝑷𝒐𝒔𝒕𝒇𝒊𝒙 𝒄𝒐𝒏𝒗𝒆𝒓𝒔𝒊𝒐𝒏 </a> </h1>
